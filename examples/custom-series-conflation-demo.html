<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Series Conflation Demo</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            margin-top: 0;
        }

        .chart-container {
            margin-top: 20px;
            height: 600px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 8px 16px;
            background-color: #2196f3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover {
            background-color: #1976d2;
        }

        .info {
            margin-top: 20px;
            padding: 15px;
            background-color: #e3f2fd;
            border-radius: 4px;
            border-left: 4px solid #2196f3;
        }

        .stats {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-card {
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 4px;
            border: 1px solid #e0e0e0;
        }

        .stat-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Custom Series Conflation Demo</h1>

        <p>This demo shows how custom series with conflation reducers can now benefit from precomputation for better performance with large datasets.</p>
        <p>The chart includes three series: a Line series, a Candlestick series, and a Whisker Box custom series with conflation.</p>

        <div class="chart-container" id="chart"></div>

        <div class="controls">
            <button id="loadSmall">Load 1K Points</button>
            <button id="loadMedium">Load 10K Points</button>
            <button id="loadLarge">Load 100K Points</button>
            <button id="toggleConflation">Toggle Conflation</button>
            <button id="zoomIn">Zoom In</button>
            <button id="zoomOut">Zoom Out</button>
            <button id="reset">Reset Chart</button>
        </div>

        <div class="stats">
            <div class="stat-card">
                <div class="stat-label">Data Points</div>
                <div class="stat-value" id="dataPoints">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Conflation Enabled</div>
                <div class="stat-value" id="conflationStatus">No</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Visible Points</div>
                <div class="stat-value" id="visiblePoints">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Render Time</div>
                <div class="stat-value" id="renderTime">0ms</div>
            </div>
        </div>

        <div class="info">
            <h3>About This Demo</h3>
            <p>This chart includes three types of series:</p>
            <ul>
                <li><strong>Line Series:</strong> A standard built-in line series</li>
                <li><strong>Candlestick Series:</strong> A standard built-in candlestick series</li>
                <li><strong>Whisker Box Series:</strong> A custom series showing quartile data with outliers, whiskers, and boxes. Implements conflation to aggregate multiple data points when zoomed out.</li>
            </ul>
            <p>When conflation is enabled and you zoom out, multiple whisker box data points are aggregated by averaging their quartiles and preserving outliers for better performance.</p>
            <p>With the recent improvements, custom series now benefit from precomputation, making zoom and pan operations much faster with large datasets.</p>
        </div>
    </div>

    <script src="../dist/lightweight-charts.standalone.production.js"></script>
    <script src="./conflation/custom-series-examples.js"></script>
    <script>
        // Initialize chart
        const chartContainer = document.getElementById('chart');
        const chart = LightweightCharts.createChart(chartContainer, {
            width: chartContainer.clientWidth,
            height: 600,
            layout: {
                background: {
                    color: '#ffffff',
                },
                textColor: '#333',
            },
            grid: {
                vertLines: {
                    color: '#f0f0f0',
                },
                horzLines: {
                    color: '#f0f0f0',
                },
            },
            crosshair: {
                mode: LightweightCharts.CrosshairMode.Normal,
            },
            timeScale: {
                borderColor: '#cccccc',
                timeVisible: true,
                secondsVisible: false,
                enableConflation: true,
                precomputeConflationOnInit: true,
                // precomputeConflationOnZoomStart: true,
				barSpacing: chartContainer.clientWidth / window.devicePixelRatio / 500000,
				minBarSpacing: chartContainer.clientWidth / 3 / 500000, // make all data visible
            },
            rightPriceScale: {
                borderColor: '#cccccc',
            },
            overlayPriceScales: {
                bordersVisible: false,
            },
        });

        // Add built-in series
        const lineSeries = chart.addSeries(LightweightCharts.LineSeries, {
            color: '#2196F3',
            title: 'Line Series',
            lineWidth: 2
        });

        const candlestickSeries = chart.addSeries(LightweightCharts.CandlestickSeries, {
            upColor: '#26a69a',
            downColor: '#ef5350',
            borderVisible: false,
            wickUpColor: '#26a69a',
            wickDownColor: '#ef5350',
            title: 'Candlestick Series'
        });

        // Add whisker box custom series
        const whiskerSeries = chart.addCustomSeries(new WhiskerBoxSeries(), {
            // priceScaleId: 'right',
            // priceLineVisible: false,
            // lastValueVisible: false,
        });

        // Stats elements
        const dataPointsEl = document.getElementById('dataPoints');
        const conflationStatusEl = document.getElementById('conflationStatus');
        const visiblePointsEl = document.getElementById('visiblePoints');
        const renderTimeEl = document.getElementById('renderTime');

        // Generate random OHLCV data
        function generateCandlestickData(count) {
            const data = [];
            let basePrice = 100;
            const dayMs = 24 * 60 * 60 * 1000;

            for (let i = 0; i < count; i++) {
                const variation = (Math.random() - 0.5) * 4;
                const open = basePrice + variation;
                const close = open + (Math.random() - 0.5) * 2;
                const high = Math.max(open, close) + Math.random() * 2;
                const low = Math.min(open, close) - Math.random() * 2;

                data.push({
                    time: dayMs + i * 60 * 1000, // 1-minute intervals
                    open,
                    high,
                    low,
                    close,
                });

                basePrice = close;
            }

            return data;
        }

        // Generate random line data
        function generateLineData(count) {
            const data = [];
            let basePrice = 100;
            const dayMs = 24 * 60 * 60 * 1000;

            for (let i = 0; i < count; i++) {
                basePrice += (Math.random() - 0.5) * 2;
                basePrice = Math.max(50, Math.min(200, basePrice)); // Keep price in reasonable range

                data.push({
                    time: dayMs + i * 60 * 1000, // 1-minute intervals
                    value: Math.round(basePrice * 100) / 100
                });
            }

            return data;
        }

        // Generate random OHLCV data for custom series
        function generateCustomSeriesData(count) {
            const data = [];
            let basePrice = 100;
            const dayMs = 24 * 60 * 60 * 1000;

            for (let i = 0; i < count; i++) {
                const variation = (Math.random() - 0.5) * 4;
                const open = basePrice + variation;
                const close = open + (Math.random() - 0.5) * 2;
                const high = Math.max(open, close) + Math.random() * 2;
                const low = Math.min(open, close) - Math.random() * 2;
                const volume = Math.floor(Math.random() * 1000000) + 100000;

                data.push({
                    time: dayMs + i * 60 * 1000, // 1-minute intervals
                    open,
                    high,
                    low,
                    close,
                    volume,
                });

                basePrice = close;
            }

            return data;
        }

        // Load data function
        function loadData(count) {
            const startTime = performance.now();
            const lineData = generateLineData(count);
            const candlestickData = generateCandlestickData(count);
            const whiskerData = sampleWhiskerData(count, 100); // Use base price of 100 to match other series

            lineSeries.setData(lineData);
            candlestickSeries.setData(candlestickData);
            whiskerSeries.setData(whiskerData);

            const endTime = performance.now();

            // Update stats
            dataPointsEl.textContent = (count * 3).toLocaleString();
            renderTimeEl.textContent = `${(endTime - startTime).toFixed(2)}ms`;

            // Update visible points after a short delay
            setTimeout(() => {
                const timeScale = chart.timeScale();
                const visibleRange = timeScale.getVisibleLogicalRange();
                if (visibleRange) {
                    const visibleCount = Math.ceil(visibleRange.to - visibleRange.from);
                    visiblePointsEl.textContent = visibleCount.toLocaleString();
                }
            }, 100);
        }

        // Button event listeners
        document.getElementById('loadSmall').addEventListener('click', () => {
            loadData(1000);
        });

        document.getElementById('loadMedium').addEventListener('click', () => {
            loadData(10000);
        });

        document.getElementById('loadLarge').addEventListener('click', () => {
            loadData(100000);
        });

        document.getElementById('toggleConflation').addEventListener('click', () => {
            const options = chart.options();
            const currentEnabled = options.timeScale.enableConflation;

            chart.applyOptions({
                timeScale: {
                    enableConflation: !currentEnabled,
                },
            });

            conflationStatusEl.textContent = !currentEnabled ? 'Yes' : 'No';
        });

        document.getElementById('zoomIn').addEventListener('click', () => {
            chart.timeScale().zoomIn(50);
        });

        document.getElementById('zoomOut').addEventListener('click', () => {
            chart.timeScale().zoomOut(50);
        });

        document.getElementById('reset').addEventListener('click', () => {
            chart.timeScale().fitContent();
        });

        // Update visible points on zoom/pan
        chart.timeScale().subscribeVisibleLogicalRangeChange(() => {
            const timeScale = chart.timeScale();
            const visibleRange = timeScale.getVisibleLogicalRange();
            if (visibleRange) {
                const visibleCount = Math.ceil(visibleRange.to - visibleRange.from);
                visiblePointsEl.textContent = visibleCount.toLocaleString();
            }
        });

        // Initialize with small dataset
        loadData(500000);

        // Handle window resize
        window.addEventListener('resize', () => {
            chart.applyOptions({
                width: chartContainer.clientWidth,
            });
        });
    </script>
</body>
</html>
